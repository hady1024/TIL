# 📌 알고리즘의 시간 복잡도

## 🎓 좋은 알고리즘이란 무엇일까 ?
- 효율성이 좋은 알고리즘 ?
- 성능이 좋은 알고리즘 ?
-  Input을 넣은 후 Output이 나오는 시간이 짧은 알고리즘 !


### 알고리즘의 소요 시간 측정하기 - 1
- 개개인의 컴퓨팅 환경에 따라 같은 알고리즘이라도 측정 시간이 다르다.
- 환경에 영향을 받지 않는 객관적인 기준이 필요하다.

### 알고리즘의 소요 시간 측정하기 - 2
- 객관적 측정을 위해 알고리즘 내부에서 기본연산이 몇 번 일어나는지 살펴본다. 
- 기본연산의 총 횟수 == 알고리즘의 소요 시간

``` python
def count(word, char):
    total = 0

    for i in word:
        if i == char:
            total += 1

    return tota
```

- 기본연산의 횟수를 구하는 것은 환경에 영향을 받지 않는 객관적인 방법이지만, 입력의 개수에 따라 시간이 달라진다는 문제가 있다.
- 따라서 성능을 측정할 때는 입력을 통일시킨다.
- 가장 기본연산이 많이 일어나는 최악의 입력 n개가 들어온다고 가정한다. ==> 입력 n개에 따른 소요 시간을 수식으로 세울 수 있다. ==> 시간 복잡도(Time Complexity)
- ``` count("aaaaa", "a")```


## 🎓 시간 복잡도 (Time Complexity)
- 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다.

        - 단순하게 알고리즘의 수행 시간을 의미한다고
        - 시간 복잡도가 높다 → 느린 알고리즘
        - 시간 복잡도가 낮다 → 빠른 알고리즘

# 📌 빅오(Big-O) 표기법

1. 6n + 4 == O(n)
2. 3n + 2 == O(n)
3. 3n^2 + 6n + 1 == O(n^2)

> 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것 최고차항만 남기고 계수와 상수 제거

> 매 입력에 따라 정확한 수식을 구하는 것은 불필요하다.정확한 수치보다는 증가율에 초점을 맞춘다.

```
O(1): 단순 산술 계산(덧셈, 뺄셈, 곱셉, 나눗셈)
O(logN): 크기 N인 리스트를 반절씩 순회/탐색
O(N): 크기 N인 리스트를 순회
O(NlogN): 크기 N인 리스트를 반절씩 탐색 * 순회
O(N^2): 크기 M, N인 2중 리스트를 순회
O(N^3): 3중 리스트를 순회
O(2^N): 크기 N 집합의 부분 집합
O(N!): 크기 N 리스트의 순열
```

``` 
O(1): 단순계산 -> a + b, 100 * 200
O(logN): 이진탐색(Binary Search), 분할정복(Divide & Conquer)
O(N): 리스트 순회, 1중 for 문
O(NlogN): 높은 성능의 정렬(Merge/Quick/Heap Sort)
O(N^2): 2중 리스트 순회, 2중 for 문
O(N^3): 3중 리스트 순회, 3중 for 문
O(2^N): 크기가 N인 집합의 부분 집합
O(N!): 크기가 N인 순열
```

### (일반적인 상황에서) 1초가 걸리는 입력의 크기

```
O(N): 1억 (기준)
O(NlogN): 500만
O(N^2): 1만
O(N^3): 500
O(2^N):20
O(N!): 10
```

### 첫 번째 방법 – 1부터 n까지 일일히 더하기

```python
def get_total(n):
    total = 0

    for i in range(1, n + 1):
        total += i

    return total

print(get_total(10))
>>> 55

print(get_total(1000000000))
>>> 제한 시간 1초 초과
```

### 두 번째 방법 – 가우스의 합 공식

``` python
def get_total(n):
    return (n * (n + 1)) // 2

print(get_total(10))
>>> 55

print(get_total(1000000000))
>>> 500000000500000000
```

- 같은 Output을 만드는 알고리즘이라도 시간 복잡도에 따라 성능이 달라질 수 있고 시험에서 정답 여부가 갈리는 포인트가 된다는 것이다.

- 내장 함수, 메서드의 시간 복잡도도 확인할 필요가 있다.



[함수 메서드에 대한 시간복잡도](https://wiki.python.org/moin/TimeComplexity)



### [참고] Big-O Cheatsheet

![dclrxt1-6983ae59-a47b-4754-962e-b17d24624b9e](시간복잡도_빅오.assets/dclrxt1-6983ae59-a47b-4754-962e-b17d24624b9e.png)


# 📌 배열 vs 연결리스트

## 🎓 1) 배열 (Array)
### 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조

- 인덱스(Index)를 통해 데이터에 빠르게 접근
- 배열의 길이는 변경 불가능 → 길이를 변경하고 싶다면 새로 생성
- 데이터 타입은 고정

``` c
int arr[5] = {70, 80, 20, 100, 90};
# C언어에서의 배열선언
```

| 메모리 주소 | 1000 | 1004 | 1008 | 1012 | 1016 | 1020 | 1024 |
| :---------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   데이터    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
|   인덱스    | A[0] | A[1] | A[2] | A[3] | A[4] | A[5] | A[6] |



## 🎓 2) 연결 리스트 (Linked List)

### 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조

- 맨 처음 노드부터 순차적으로 탐색
- 연결리스트의 길이 자유롭게 변경 가능 → 삽입, 삭제가 편리
- 다양한 데이터 타입 저장
- 데이터가 메모리에 연속적으로 저장되지 않음



# 📌 파이썬의 리스트

### 파이썬 리스트의 메서드

1. .append(원소)**O(1)** : 리스트 맨 끝에 새로운 원소 **삽입(리턴값이 없다)**
2. .pop(인덱스)**O(1)** : 특정 인덱스에 있는 원소를 **삭제 및 반환(리턴값이 있다)**
3. .count(원소)**O(N)** : 리스트에서 해당 원소의 **개수를 반환**
4. .index(원소)**O(N)** : 리스트에서 처음으로 원소가 등장하는 **인덱스** 반환
5. .sort()**O(N Log N)**: 리스트를 오름차순으로 **정렬** reverse() = True를 통해 내림차순으로 정렬 가능

6. .reverse()**O(N)** : 리스트의 원소들의 순서를 거꾸로 뒤집기



### 자주 쓰이는 리스트 관련 내장함수

1. len(iterable)**O(1)** : 리스트 **길이(원소의 개수)** 반환
2. sum(iterable)**O(N)** : 리스트의 모든 원소의 **합** 반환
3. max(iterable)**O(N)** : 리스트 원소 중 **최대값** 반환
4. min(iterable) : 리스트 원소 중 **최소값** 반환
5. sorted(iterable) : 오름차순으로 **정렬**된 새로운 리스트 반환, 원본 리스트는 변화 없음



# 📌 리스트 컴프리헨션 (List  Comprehension)

> List Comprehension(리스트 컴프리헨션, 리스트 내포)란 코드 한 줄만으로 새로운 리스트를 만드는 방법이다.

