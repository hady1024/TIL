# 알고리즘의 시간 복잡도

## 좋은 알고리즘이란 무엇일까 ?
- 효율성이 좋은 알고리즘 ?
- 성능이 좋은 알고리즘 ?
-  Input을 넣은 후 Output이 나오는 시간이 짧은 알고리즘 !


### 알고리즘의 소요 시간 측정하기 - 1
- 개개인의 컴퓨팅 환경에 따라 같은 알고리즘이라도 측정 시간이 다르다.
- 환경에 영향을 받지 않는 객관적인 기준이 필요하다.

### 알고리즘의 소요 시간 측정하기 - 2
- 객관적 측정을 위해 알고리즘 내부에서 기본연산이 몇 번 일어나는지 살펴본다. 
- 기본연산의 총 횟수 == 알고리즘의 소요 시간

``` python
def count(word, char):
    total = 0

    for i in word:
        if i == char:
            total += 1

    return tota
```

- 기본연산의 횟수를 구하는 것은 환경에 영향을 받지 않는 객관적인 방법이지만, 입력의 개수에 따라 시간이 달라진다는 문제가 있다.
- 따라서 성능을 측정할 때는 입력을 통일시킨다.
- 가장 기본연산이 많이 일어나는 최악의 입력 n개가 들어온다고 가정한다. ==> 입력 n개에 따른 소요 시간을 수식으로 세울 수 있다. ==> 시간 복잡도(Time Complexity)
- ``` count("aaaaa", "a")```


## 시간 복잡도 (Time Complexity)
- 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다.

        - 단순하게 알고리즘의 수행 시간을 의미한다고
        - 시간 복잡도가 높다 → 느린 알고리즘
        - 시간 복잡도가 낮다 → 빠른 알고리즘

# 빅오(Big-O) 표기법

1. 6n + 4 == O(n)
2. 3n + 2 == O(n)
3. 3n^2 + 6n + 1 == O(n^2)

> 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것 최고차항만 남기고 계수와 상수 제거

> 매 입력에 따라 정확한 수식을 구하는 것은 불필요하다.정확한 수치보다는 증가율에 초점을 맞춘다.

```
O(1): 단순 산술 계산(덧셈, 뺄셈, 곱셉, 나눗셈)
O(logN): 크기 N인 리스트를 반절씩 순회/탐색
O(N): 크기 N인 리스트를 순회
O(NlogN): 크기 N인 리스트를 반절씩 탐색 * 순회
O(N^2): 크기 M, N인 2중 리스트를 순회
O(N^3): 3중 리스트를 순회
O(2^N): 크기 N 집합의 부분 집합
O(N!): 크기 N 리스트의 순열
```

``` 
O(1): 단순계산 -> a + b, 100 * 200
O(logN): 이진탐색(Binary Search), 분할정복(Divide & Conquer)
O(N): 리스트 순회, 1중 for 문
O(NlogN): 높은 성능의 정렬(Merge/Quick/Heap Sort)
O(N^2): 2중 리스트 순회, 2중 for 문
O(N^3): 3중 리스트 순회, 3중 for 문
O(2^N): 크기가 N인 집합의 부분 집합
O(N!): 크기가 N인 순열
```

### (일반적인 상황에서) 1초가 걸리는 입력의 크기

```
O(N): 1억 (기준)
O(NlogN): 500만
O(N^2): 1만
O(N^3): 500
O(2^N):20
O(N!): 10
```

### 첫 번째 방법 – 1부터 n까지 일일히 더하기

```python
def get_total(n):
    total = 0

    for i in range(1, n + 1):
        total += i

    return total

print(get_total(10))
>>> 55

print(get_total(1000000000))
>>> 제한 시간 1초 초과
```

### 두 번째 방법 – 가우스의 합 공식

``` python
def get_total(n):
    return (n * (n + 1)) // 2

print(get_total(10))
>>> 55

print(get_total(1000000000))
>>> 500000000500000000
```

- 같은 Output을 만드는 알고리즘이라도 시간 복잡도에 따라 성능이 달라질 수 있고 시험에서 정답 여부가 갈리는 포인트가 된다는 것이다.

- 내장 함수, 메서드의 시간 복잡도도 확인할 필요가 있다.


# 배열 vs 연결리스트

## 1) 배열 (Array)
### 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조

- 인덱스(Index)를 통해 데이터에 빠르게 접근
- 배열의 길이는 변경 불가능 → 길이를 변경하고 싶다면 새로 생성
- 데이터 타입은 고정

``` c
int arr[5] = {70, 80, 20, 100, 90};
# C언어에서의 배열선언
```
